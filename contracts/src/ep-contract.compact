pragma language_version 0.18;

import CompactStandardLibrary;

// Private payslip data supplied off-chain via a witness
struct PayslipWitness {
  name: Bytes<32>;
  dob: Bytes<32>;
  netPay: Uint<64>;
  salt: Bytes<32>;
}

// What we store on-chain per request
struct VerificationResult {
  identityHash: Bytes<32>; // fingerprint for (name, dob[, salt...])
  provenLimit: Uint<64>;   // income limit that was actually checked
}

witness getPayslip(): PayslipWitness;

// Map<RequestId, VerificationResult>
export ledger verifications: Map<Bytes<32>, VerificationResult>;

// Helper circuit
circuit identityFingerprint(name: Bytes<32>, dob: Bytes<32>): Bytes<32> {
  const payload: Vector<3, Bytes<32>> =
    [ pad(32, "income-fp")   // domain separator
    , name
    , dob
    ];
  return persistentHash<Vector<3, Bytes<32>>>(payload);
}

// Generate circuit
export circuit proveIncome(limit: Uint<64>, requestId: Bytes<32>): [] {
  const payslip = getPayslip();

  assert(payslip.netPay >= limit, "Income too low");

  const fp = identityFingerprint(payslip.name, payslip.dob);

  const result = VerificationResult {
    identityHash: fp,
    provenLimit: limit,
  };

  verifications.insert(disclose(requestId), disclose(result));
}

// Verify circuit 
export circuit getVerifiedResult(
  requestId: Bytes<32>,
  name: Bytes<32>,
  dob: Bytes<32>
): VerificationResult {

  const stored: VerificationResult = verifications.lookup(disclose(requestId));
  
  const expected = identityFingerprint(name, dob);

  assert(stored.identityHash == expected, "identity mismatch");

  return stored;
}